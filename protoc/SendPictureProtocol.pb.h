// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SendPictureProtocol.proto

#ifndef PROTOBUF_SendPictureProtocol_2eproto__INCLUDED
#define PROTOBUF_SendPictureProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace PictureProtocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SendPictureProtocol_2eproto();
void protobuf_AssignDesc_SendPictureProtocol_2eproto();
void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

class Head;
class CameraMessage;
class Login;
class LoginResult;
class ChangeCamera;
class SendFaceMessage;
class SendCarMessage;
class SendBackMessage;
class RectPicture;
class CameraStatus;
class CameraStatusList;

enum LoginResult_Flag {
  LoginResult_Flag_ok = 1,
  LoginResult_Flag_fail = 2,
  LoginResult_Flag_update_version = 3
};
bool LoginResult_Flag_IsValid(int value);
const LoginResult_Flag LoginResult_Flag_Flag_MIN = LoginResult_Flag_ok;
const LoginResult_Flag LoginResult_Flag_Flag_MAX = LoginResult_Flag_update_version;
const int LoginResult_Flag_Flag_ARRAYSIZE = LoginResult_Flag_Flag_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginResult_Flag_descriptor();
inline const ::std::string& LoginResult_Flag_Name(LoginResult_Flag value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginResult_Flag_descriptor(), value);
}
inline bool LoginResult_Flag_Parse(
    const ::std::string& name, LoginResult_Flag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginResult_Flag>(
    LoginResult_Flag_descriptor(), name, value);
}
enum MessageType {
  LOGIN = 10,
  LOGIN_RESULT = 11,
  SEND_FACE_MESSAGE = 12,
  SEND_BACK_MESSAGE = 13,
  SEND_CAR_MESSAGE = 14,
  CAMERA_STATUS_MESSAGE = 15
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = LOGIN;
const MessageType MessageType_MAX = CAMERA_STATUS_MESSAGE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Head : public ::google::protobuf::Message {
 public:
  Head();
  virtual ~Head();

  Head(const Head& from);

  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Head& default_instance();

  void Swap(Head* other);

  // implements Message ----------------------------------------------

  Head* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 message_size = 1;
  inline bool has_message_size() const;
  inline void clear_message_size();
  static const int kMessageSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 message_size() const;
  inline void set_message_size(::google::protobuf::uint32 value);

  // required fixed32 message_type = 2;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 message_type() const;
  inline void set_message_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PictureProtocol.Head)
 private:
  inline void set_has_message_size();
  inline void clear_has_message_size();
  inline void set_has_message_type();
  inline void clear_has_message_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 message_size_;
  ::google::protobuf::uint32 message_type_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static Head* default_instance_;
};
// -------------------------------------------------------------------

class CameraMessage : public ::google::protobuf::Message {
 public:
  CameraMessage();
  virtual ~CameraMessage();

  CameraMessage(const CameraMessage& from);

  inline CameraMessage& operator=(const CameraMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMessage& default_instance();

  void Swap(CameraMessage* other);

  // implements Message ----------------------------------------------

  CameraMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraMessage& from);
  void MergeFrom(const CameraMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 camera_id = 1;
  inline bool has_camera_id() const;
  inline void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  inline ::google::protobuf::uint64 camera_id() const;
  inline void set_camera_id(::google::protobuf::uint64 value);

  // required string camera_ip = 2;
  inline bool has_camera_ip() const;
  inline void clear_camera_ip();
  static const int kCameraIpFieldNumber = 2;
  inline const ::std::string& camera_ip() const;
  inline void set_camera_ip(const ::std::string& value);
  inline void set_camera_ip(const char* value);
  inline void set_camera_ip(const char* value, size_t size);
  inline ::std::string* mutable_camera_ip();
  inline ::std::string* release_camera_ip();
  inline void set_allocated_camera_ip(::std::string* camera_ip);

  // required uint32 camera_port = 3;
  inline bool has_camera_port() const;
  inline void clear_camera_port();
  static const int kCameraPortFieldNumber = 3;
  inline ::google::protobuf::uint32 camera_port() const;
  inline void set_camera_port(::google::protobuf::uint32 value);

  // required string camera_username = 4;
  inline bool has_camera_username() const;
  inline void clear_camera_username();
  static const int kCameraUsernameFieldNumber = 4;
  inline const ::std::string& camera_username() const;
  inline void set_camera_username(const ::std::string& value);
  inline void set_camera_username(const char* value);
  inline void set_camera_username(const char* value, size_t size);
  inline ::std::string* mutable_camera_username();
  inline ::std::string* release_camera_username();
  inline void set_allocated_camera_username(::std::string* camera_username);

  // required string camera_passowrd = 5;
  inline bool has_camera_passowrd() const;
  inline void clear_camera_passowrd();
  static const int kCameraPassowrdFieldNumber = 5;
  inline const ::std::string& camera_passowrd() const;
  inline void set_camera_passowrd(const ::std::string& value);
  inline void set_camera_passowrd(const char* value);
  inline void set_camera_passowrd(const char* value, size_t size);
  inline ::std::string* mutable_camera_passowrd();
  inline ::std::string* release_camera_passowrd();
  inline void set_allocated_camera_passowrd(::std::string* camera_passowrd);

  // @@protoc_insertion_point(class_scope:PictureProtocol.CameraMessage)
 private:
  inline void set_has_camera_id();
  inline void clear_has_camera_id();
  inline void set_has_camera_ip();
  inline void clear_has_camera_ip();
  inline void set_has_camera_port();
  inline void clear_has_camera_port();
  inline void set_has_camera_username();
  inline void clear_has_camera_username();
  inline void set_has_camera_passowrd();
  inline void clear_has_camera_passowrd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 camera_id_;
  ::std::string* camera_ip_;
  ::std::string* camera_username_;
  ::std::string* camera_passowrd_;
  ::google::protobuf::uint32 camera_port_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static CameraMessage* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required uint32 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required string os = 5;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 5;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // @@protoc_insertion_point(class_scope:PictureProtocol.Login)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_os();
  inline void clear_has_os();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* os_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class LoginResult : public ::google::protobuf::Message {
 public:
  LoginResult();
  virtual ~LoginResult();

  LoginResult(const LoginResult& from);

  inline LoginResult& operator=(const LoginResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResult& default_instance();

  void Swap(LoginResult* other);

  // implements Message ----------------------------------------------

  LoginResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResult& from);
  void MergeFrom(const LoginResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoginResult_Flag Flag;
  static const Flag ok = LoginResult_Flag_ok;
  static const Flag fail = LoginResult_Flag_fail;
  static const Flag update_version = LoginResult_Flag_update_version;
  static inline bool Flag_IsValid(int value) {
    return LoginResult_Flag_IsValid(value);
  }
  static const Flag Flag_MIN =
    LoginResult_Flag_Flag_MIN;
  static const Flag Flag_MAX =
    LoginResult_Flag_Flag_MAX;
  static const int Flag_ARRAYSIZE =
    LoginResult_Flag_Flag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Flag_descriptor() {
    return LoginResult_Flag_descriptor();
  }
  static inline const ::std::string& Flag_Name(Flag value) {
    return LoginResult_Flag_Name(value);
  }
  static inline bool Flag_Parse(const ::std::string& name,
      Flag* value) {
    return LoginResult_Flag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .PictureProtocol.LoginResult.Flag flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::PictureProtocol::LoginResult_Flag flag() const;
  inline void set_flag(::PictureProtocol::LoginResult_Flag value);

  // repeated .PictureProtocol.CameraMessage camera_message = 2;
  inline int camera_message_size() const;
  inline void clear_camera_message();
  static const int kCameraMessageFieldNumber = 2;
  inline const ::PictureProtocol::CameraMessage& camera_message(int index) const;
  inline ::PictureProtocol::CameraMessage* mutable_camera_message(int index);
  inline ::PictureProtocol::CameraMessage* add_camera_message();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >&
      camera_message() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >*
      mutable_camera_message();

  // optional string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:PictureProtocol.LoginResult)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage > camera_message_;
  ::std::string* message_;
  int flag_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoginResult* default_instance_;
};
// -------------------------------------------------------------------

class ChangeCamera : public ::google::protobuf::Message {
 public:
  ChangeCamera();
  virtual ~ChangeCamera();

  ChangeCamera(const ChangeCamera& from);

  inline ChangeCamera& operator=(const ChangeCamera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeCamera& default_instance();

  void Swap(ChangeCamera* other);

  // implements Message ----------------------------------------------

  ChangeCamera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeCamera& from);
  void MergeFrom(const ChangeCamera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PictureProtocol.CameraMessage camera_message = 1;
  inline int camera_message_size() const;
  inline void clear_camera_message();
  static const int kCameraMessageFieldNumber = 1;
  inline const ::PictureProtocol::CameraMessage& camera_message(int index) const;
  inline ::PictureProtocol::CameraMessage* mutable_camera_message(int index);
  inline ::PictureProtocol::CameraMessage* add_camera_message();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >&
      camera_message() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >*
      mutable_camera_message();

  // @@protoc_insertion_point(class_scope:PictureProtocol.ChangeCamera)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage > camera_message_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static ChangeCamera* default_instance_;
};
// -------------------------------------------------------------------

class SendFaceMessage : public ::google::protobuf::Message {
 public:
  SendFaceMessage();
  virtual ~SendFaceMessage();

  SendFaceMessage(const SendFaceMessage& from);

  inline SendFaceMessage& operator=(const SendFaceMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendFaceMessage& default_instance();

  void Swap(SendFaceMessage* other);

  // implements Message ----------------------------------------------

  SendFaceMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendFaceMessage& from);
  void MergeFrom(const SendFaceMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 camera_id = 1;
  inline bool has_camera_id() const;
  inline void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  inline ::google::protobuf::uint64 camera_id() const;
  inline void set_camera_id(::google::protobuf::uint64 value);

  // required uint32 face_score = 2;
  inline bool has_face_score() const;
  inline void clear_face_score();
  static const int kFaceScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 face_score() const;
  inline void set_face_score(::google::protobuf::uint32 value);

  // required bytes face_contrast_pic = 3;
  inline bool has_face_contrast_pic() const;
  inline void clear_face_contrast_pic();
  static const int kFaceContrastPicFieldNumber = 3;
  inline const ::std::string& face_contrast_pic() const;
  inline void set_face_contrast_pic(const ::std::string& value);
  inline void set_face_contrast_pic(const char* value);
  inline void set_face_contrast_pic(const void* value, size_t size);
  inline ::std::string* mutable_face_contrast_pic();
  inline ::std::string* release_face_contrast_pic();
  inline void set_allocated_face_contrast_pic(::std::string* face_contrast_pic);

  // optional .PictureProtocol.RectPicture rect_pic_face = 4;
  inline bool has_rect_pic_face() const;
  inline void clear_rect_pic_face();
  static const int kRectPicFaceFieldNumber = 4;
  inline const ::PictureProtocol::RectPicture& rect_pic_face() const;
  inline ::PictureProtocol::RectPicture* mutable_rect_pic_face();
  inline ::PictureProtocol::RectPicture* release_rect_pic_face();
  inline void set_allocated_rect_pic_face(::PictureProtocol::RectPicture* rect_pic_face);

  // optional bytes face_show_pic = 5;
  inline bool has_face_show_pic() const;
  inline void clear_face_show_pic();
  static const int kFaceShowPicFieldNumber = 5;
  inline const ::std::string& face_show_pic() const;
  inline void set_face_show_pic(const ::std::string& value);
  inline void set_face_show_pic(const char* value);
  inline void set_face_show_pic(const void* value, size_t size);
  inline ::std::string* mutable_face_show_pic();
  inline ::std::string* release_face_show_pic();
  inline void set_allocated_face_show_pic(::std::string* face_show_pic);

  // optional .PictureProtocol.RectPicture rect_pic_show = 6;
  inline bool has_rect_pic_show() const;
  inline void clear_rect_pic_show();
  static const int kRectPicShowFieldNumber = 6;
  inline const ::PictureProtocol::RectPicture& rect_pic_show() const;
  inline ::PictureProtocol::RectPicture* mutable_rect_pic_show();
  inline ::PictureProtocol::RectPicture* release_rect_pic_show();
  inline void set_allocated_rect_pic_show(::PictureProtocol::RectPicture* rect_pic_show);

  // required uint64 camera_time = 7;
  inline bool has_camera_time() const;
  inline void clear_camera_time();
  static const int kCameraTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 camera_time() const;
  inline void set_camera_time(::google::protobuf::uint64 value);

  // required uint64 program_time = 8;
  inline bool has_program_time() const;
  inline void clear_program_time();
  static const int kProgramTimeFieldNumber = 8;
  inline ::google::protobuf::uint64 program_time() const;
  inline void set_program_time(::google::protobuf::uint64 value);

  // required uint64 send_time = 9;
  inline bool has_send_time() const;
  inline void clear_send_time();
  static const int kSendTimeFieldNumber = 9;
  inline ::google::protobuf::uint64 send_time() const;
  inline void set_send_time(::google::protobuf::uint64 value);

  // required string picture_name = 10;
  inline bool has_picture_name() const;
  inline void clear_picture_name();
  static const int kPictureNameFieldNumber = 10;
  inline const ::std::string& picture_name() const;
  inline void set_picture_name(const ::std::string& value);
  inline void set_picture_name(const char* value);
  inline void set_picture_name(const char* value, size_t size);
  inline ::std::string* mutable_picture_name();
  inline ::std::string* release_picture_name();
  inline void set_allocated_picture_name(::std::string* picture_name);

  // optional bytes back_pic = 11;
  inline bool has_back_pic() const;
  inline void clear_back_pic();
  static const int kBackPicFieldNumber = 11;
  inline const ::std::string& back_pic() const;
  inline void set_back_pic(const ::std::string& value);
  inline void set_back_pic(const char* value);
  inline void set_back_pic(const void* value, size_t size);
  inline ::std::string* mutable_back_pic();
  inline ::std::string* release_back_pic();
  inline void set_allocated_back_pic(::std::string* back_pic);

  // optional .PictureProtocol.RectPicture rect_pic_back = 12;
  inline bool has_rect_pic_back() const;
  inline void clear_rect_pic_back();
  static const int kRectPicBackFieldNumber = 12;
  inline const ::PictureProtocol::RectPicture& rect_pic_back() const;
  inline ::PictureProtocol::RectPicture* mutable_rect_pic_back();
  inline ::PictureProtocol::RectPicture* release_rect_pic_back();
  inline void set_allocated_rect_pic_back(::PictureProtocol::RectPicture* rect_pic_back);

  // @@protoc_insertion_point(class_scope:PictureProtocol.SendFaceMessage)
 private:
  inline void set_has_camera_id();
  inline void clear_has_camera_id();
  inline void set_has_face_score();
  inline void clear_has_face_score();
  inline void set_has_face_contrast_pic();
  inline void clear_has_face_contrast_pic();
  inline void set_has_rect_pic_face();
  inline void clear_has_rect_pic_face();
  inline void set_has_face_show_pic();
  inline void clear_has_face_show_pic();
  inline void set_has_rect_pic_show();
  inline void clear_has_rect_pic_show();
  inline void set_has_camera_time();
  inline void clear_has_camera_time();
  inline void set_has_program_time();
  inline void clear_has_program_time();
  inline void set_has_send_time();
  inline void clear_has_send_time();
  inline void set_has_picture_name();
  inline void clear_has_picture_name();
  inline void set_has_back_pic();
  inline void clear_has_back_pic();
  inline void set_has_rect_pic_back();
  inline void clear_has_rect_pic_back();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 camera_id_;
  ::std::string* face_contrast_pic_;
  ::PictureProtocol::RectPicture* rect_pic_face_;
  ::std::string* face_show_pic_;
  ::PictureProtocol::RectPicture* rect_pic_show_;
  ::google::protobuf::uint64 camera_time_;
  ::google::protobuf::uint64 program_time_;
  ::google::protobuf::uint64 send_time_;
  ::std::string* picture_name_;
  ::std::string* back_pic_;
  ::PictureProtocol::RectPicture* rect_pic_back_;
  ::google::protobuf::uint32 face_score_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static SendFaceMessage* default_instance_;
};
// -------------------------------------------------------------------

class SendCarMessage : public ::google::protobuf::Message {
 public:
  SendCarMessage();
  virtual ~SendCarMessage();

  SendCarMessage(const SendCarMessage& from);

  inline SendCarMessage& operator=(const SendCarMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendCarMessage& default_instance();

  void Swap(SendCarMessage* other);

  // implements Message ----------------------------------------------

  SendCarMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendCarMessage& from);
  void MergeFrom(const SendCarMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 camera_id = 1;
  inline bool has_camera_id() const;
  inline void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  inline ::google::protobuf::uint64 camera_id() const;
  inline void set_camera_id(::google::protobuf::uint64 value);

  // required uint32 license_score = 2;
  inline bool has_license_score() const;
  inline void clear_license_score();
  static const int kLicenseScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 license_score() const;
  inline void set_license_score(::google::protobuf::uint32 value);

  // required string license_plate_num = 3;
  inline bool has_license_plate_num() const;
  inline void clear_license_plate_num();
  static const int kLicensePlateNumFieldNumber = 3;
  inline const ::std::string& license_plate_num() const;
  inline void set_license_plate_num(const ::std::string& value);
  inline void set_license_plate_num(const char* value);
  inline void set_license_plate_num(const char* value, size_t size);
  inline ::std::string* mutable_license_plate_num();
  inline ::std::string* release_license_plate_num();
  inline void set_allocated_license_plate_num(::std::string* license_plate_num);

  // optional string license_plate_color = 4;
  inline bool has_license_plate_color() const;
  inline void clear_license_plate_color();
  static const int kLicensePlateColorFieldNumber = 4;
  inline const ::std::string& license_plate_color() const;
  inline void set_license_plate_color(const ::std::string& value);
  inline void set_license_plate_color(const char* value);
  inline void set_license_plate_color(const char* value, size_t size);
  inline ::std::string* mutable_license_plate_color();
  inline ::std::string* release_license_plate_color();
  inline void set_allocated_license_plate_color(::std::string* license_plate_color);

  // optional string license_car_color = 5;
  inline bool has_license_car_color() const;
  inline void clear_license_car_color();
  static const int kLicenseCarColorFieldNumber = 5;
  inline const ::std::string& license_car_color() const;
  inline void set_license_car_color(const ::std::string& value);
  inline void set_license_car_color(const char* value);
  inline void set_license_car_color(const char* value, size_t size);
  inline ::std::string* mutable_license_car_color();
  inline ::std::string* release_license_car_color();
  inline void set_allocated_license_car_color(::std::string* license_car_color);

  // optional string license_plate_type = 6;
  inline bool has_license_plate_type() const;
  inline void clear_license_plate_type();
  static const int kLicensePlateTypeFieldNumber = 6;
  inline const ::std::string& license_plate_type() const;
  inline void set_license_plate_type(const ::std::string& value);
  inline void set_license_plate_type(const char* value);
  inline void set_license_plate_type(const char* value, size_t size);
  inline ::std::string* mutable_license_plate_type();
  inline ::std::string* release_license_plate_type();
  inline void set_allocated_license_plate_type(::std::string* license_plate_type);

  // required bytes license_plate_pic = 7;
  inline bool has_license_plate_pic() const;
  inline void clear_license_plate_pic();
  static const int kLicensePlatePicFieldNumber = 7;
  inline const ::std::string& license_plate_pic() const;
  inline void set_license_plate_pic(const ::std::string& value);
  inline void set_license_plate_pic(const char* value);
  inline void set_license_plate_pic(const void* value, size_t size);
  inline ::std::string* mutable_license_plate_pic();
  inline ::std::string* release_license_plate_pic();
  inline void set_allocated_license_plate_pic(::std::string* license_plate_pic);

  // optional .PictureProtocol.RectPicture rect_pic_license = 8;
  inline bool has_rect_pic_license() const;
  inline void clear_rect_pic_license();
  static const int kRectPicLicenseFieldNumber = 8;
  inline const ::PictureProtocol::RectPicture& rect_pic_license() const;
  inline ::PictureProtocol::RectPicture* mutable_rect_pic_license();
  inline ::PictureProtocol::RectPicture* release_rect_pic_license();
  inline void set_allocated_rect_pic_license(::PictureProtocol::RectPicture* rect_pic_license);

  // required uint64 camera_time = 9;
  inline bool has_camera_time() const;
  inline void clear_camera_time();
  static const int kCameraTimeFieldNumber = 9;
  inline ::google::protobuf::uint64 camera_time() const;
  inline void set_camera_time(::google::protobuf::uint64 value);

  // required uint64 program_time = 10;
  inline bool has_program_time() const;
  inline void clear_program_time();
  static const int kProgramTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 program_time() const;
  inline void set_program_time(::google::protobuf::uint64 value);

  // required string picture_name = 11;
  inline bool has_picture_name() const;
  inline void clear_picture_name();
  static const int kPictureNameFieldNumber = 11;
  inline const ::std::string& picture_name() const;
  inline void set_picture_name(const ::std::string& value);
  inline void set_picture_name(const char* value);
  inline void set_picture_name(const char* value, size_t size);
  inline ::std::string* mutable_picture_name();
  inline ::std::string* release_picture_name();
  inline void set_allocated_picture_name(::std::string* picture_name);

  // optional bytes back_pic = 12;
  inline bool has_back_pic() const;
  inline void clear_back_pic();
  static const int kBackPicFieldNumber = 12;
  inline const ::std::string& back_pic() const;
  inline void set_back_pic(const ::std::string& value);
  inline void set_back_pic(const char* value);
  inline void set_back_pic(const void* value, size_t size);
  inline ::std::string* mutable_back_pic();
  inline ::std::string* release_back_pic();
  inline void set_allocated_back_pic(::std::string* back_pic);

  // optional .PictureProtocol.RectPicture rect_pic_back = 13;
  inline bool has_rect_pic_back() const;
  inline void clear_rect_pic_back();
  static const int kRectPicBackFieldNumber = 13;
  inline const ::PictureProtocol::RectPicture& rect_pic_back() const;
  inline ::PictureProtocol::RectPicture* mutable_rect_pic_back();
  inline ::PictureProtocol::RectPicture* release_rect_pic_back();
  inline void set_allocated_rect_pic_back(::PictureProtocol::RectPicture* rect_pic_back);

  // @@protoc_insertion_point(class_scope:PictureProtocol.SendCarMessage)
 private:
  inline void set_has_camera_id();
  inline void clear_has_camera_id();
  inline void set_has_license_score();
  inline void clear_has_license_score();
  inline void set_has_license_plate_num();
  inline void clear_has_license_plate_num();
  inline void set_has_license_plate_color();
  inline void clear_has_license_plate_color();
  inline void set_has_license_car_color();
  inline void clear_has_license_car_color();
  inline void set_has_license_plate_type();
  inline void clear_has_license_plate_type();
  inline void set_has_license_plate_pic();
  inline void clear_has_license_plate_pic();
  inline void set_has_rect_pic_license();
  inline void clear_has_rect_pic_license();
  inline void set_has_camera_time();
  inline void clear_has_camera_time();
  inline void set_has_program_time();
  inline void clear_has_program_time();
  inline void set_has_picture_name();
  inline void clear_has_picture_name();
  inline void set_has_back_pic();
  inline void clear_has_back_pic();
  inline void set_has_rect_pic_back();
  inline void clear_has_rect_pic_back();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 camera_id_;
  ::std::string* license_plate_num_;
  ::std::string* license_plate_color_;
  ::std::string* license_car_color_;
  ::std::string* license_plate_type_;
  ::std::string* license_plate_pic_;
  ::PictureProtocol::RectPicture* rect_pic_license_;
  ::google::protobuf::uint64 camera_time_;
  ::google::protobuf::uint64 program_time_;
  ::std::string* picture_name_;
  ::std::string* back_pic_;
  ::PictureProtocol::RectPicture* rect_pic_back_;
  ::google::protobuf::uint32 license_score_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static SendCarMessage* default_instance_;
};
// -------------------------------------------------------------------

class SendBackMessage : public ::google::protobuf::Message {
 public:
  SendBackMessage();
  virtual ~SendBackMessage();

  SendBackMessage(const SendBackMessage& from);

  inline SendBackMessage& operator=(const SendBackMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendBackMessage& default_instance();

  void Swap(SendBackMessage* other);

  // implements Message ----------------------------------------------

  SendBackMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendBackMessage& from);
  void MergeFrom(const SendBackMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 camera_id = 1;
  inline bool has_camera_id() const;
  inline void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  inline ::google::protobuf::uint64 camera_id() const;
  inline void set_camera_id(::google::protobuf::uint64 value);

  // required bytes back_pic = 2;
  inline bool has_back_pic() const;
  inline void clear_back_pic();
  static const int kBackPicFieldNumber = 2;
  inline const ::std::string& back_pic() const;
  inline void set_back_pic(const ::std::string& value);
  inline void set_back_pic(const char* value);
  inline void set_back_pic(const void* value, size_t size);
  inline ::std::string* mutable_back_pic();
  inline ::std::string* release_back_pic();
  inline void set_allocated_back_pic(::std::string* back_pic);

  // required .PictureProtocol.RectPicture rect_pic_back = 3;
  inline bool has_rect_pic_back() const;
  inline void clear_rect_pic_back();
  static const int kRectPicBackFieldNumber = 3;
  inline const ::PictureProtocol::RectPicture& rect_pic_back() const;
  inline ::PictureProtocol::RectPicture* mutable_rect_pic_back();
  inline ::PictureProtocol::RectPicture* release_rect_pic_back();
  inline void set_allocated_rect_pic_back(::PictureProtocol::RectPicture* rect_pic_back);

  // required string picture_name = 4;
  inline bool has_picture_name() const;
  inline void clear_picture_name();
  static const int kPictureNameFieldNumber = 4;
  inline const ::std::string& picture_name() const;
  inline void set_picture_name(const ::std::string& value);
  inline void set_picture_name(const char* value);
  inline void set_picture_name(const char* value, size_t size);
  inline ::std::string* mutable_picture_name();
  inline ::std::string* release_picture_name();
  inline void set_allocated_picture_name(::std::string* picture_name);

  // @@protoc_insertion_point(class_scope:PictureProtocol.SendBackMessage)
 private:
  inline void set_has_camera_id();
  inline void clear_has_camera_id();
  inline void set_has_back_pic();
  inline void clear_has_back_pic();
  inline void set_has_rect_pic_back();
  inline void clear_has_rect_pic_back();
  inline void set_has_picture_name();
  inline void clear_has_picture_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 camera_id_;
  ::std::string* back_pic_;
  ::PictureProtocol::RectPicture* rect_pic_back_;
  ::std::string* picture_name_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static SendBackMessage* default_instance_;
};
// -------------------------------------------------------------------

class RectPicture : public ::google::protobuf::Message {
 public:
  RectPicture();
  virtual ~RectPicture();

  RectPicture(const RectPicture& from);

  inline RectPicture& operator=(const RectPicture& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RectPicture& default_instance();

  void Swap(RectPicture* other);

  // implements Message ----------------------------------------------

  RectPicture* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RectPicture& from);
  void MergeFrom(const RectPicture& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // required uint32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PictureProtocol.RectPicture)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static RectPicture* default_instance_;
};
// -------------------------------------------------------------------

class CameraStatus : public ::google::protobuf::Message {
 public:
  CameraStatus();
  virtual ~CameraStatus();

  CameraStatus(const CameraStatus& from);

  inline CameraStatus& operator=(const CameraStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraStatus& default_instance();

  void Swap(CameraStatus* other);

  // implements Message ----------------------------------------------

  CameraStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraStatus& from);
  void MergeFrom(const CameraStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 camera_id = 1;
  inline bool has_camera_id() const;
  inline void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  inline ::google::protobuf::uint64 camera_id() const;
  inline void set_camera_id(::google::protobuf::uint64 value);

  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // @@protoc_insertion_point(class_scope:PictureProtocol.CameraStatus)
 private:
  inline void set_has_camera_id();
  inline void clear_has_camera_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 camera_id_;
  bool status_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static CameraStatus* default_instance_;
};
// -------------------------------------------------------------------

class CameraStatusList : public ::google::protobuf::Message {
 public:
  CameraStatusList();
  virtual ~CameraStatusList();

  CameraStatusList(const CameraStatusList& from);

  inline CameraStatusList& operator=(const CameraStatusList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraStatusList& default_instance();

  void Swap(CameraStatusList* other);

  // implements Message ----------------------------------------------

  CameraStatusList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraStatusList& from);
  void MergeFrom(const CameraStatusList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PictureProtocol.CameraStatus cameraStatus = 1;
  inline int camerastatus_size() const;
  inline void clear_camerastatus();
  static const int kCameraStatusFieldNumber = 1;
  inline const ::PictureProtocol::CameraStatus& camerastatus(int index) const;
  inline ::PictureProtocol::CameraStatus* mutable_camerastatus(int index);
  inline ::PictureProtocol::CameraStatus* add_camerastatus();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraStatus >&
      camerastatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraStatus >*
      mutable_camerastatus();

  // @@protoc_insertion_point(class_scope:PictureProtocol.CameraStatusList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraStatus > camerastatus_;
  friend void  protobuf_AddDesc_SendPictureProtocol_2eproto();
  friend void protobuf_AssignDesc_SendPictureProtocol_2eproto();
  friend void protobuf_ShutdownFile_SendPictureProtocol_2eproto();

  void InitAsDefaultInstance();
  static CameraStatusList* default_instance_;
};
// ===================================================================


// ===================================================================

// Head

// required fixed32 message_size = 1;
inline bool Head::has_message_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_message_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Head::clear_has_message_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Head::clear_message_size() {
  message_size_ = 0u;
  clear_has_message_size();
}
inline ::google::protobuf::uint32 Head::message_size() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.Head.message_size)
  return message_size_;
}
inline void Head::set_message_size(::google::protobuf::uint32 value) {
  set_has_message_size();
  message_size_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.Head.message_size)
}

// required fixed32 message_type = 2;
inline bool Head::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Head::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Head::clear_message_type() {
  message_type_ = 0u;
  clear_has_message_type();
}
inline ::google::protobuf::uint32 Head::message_type() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.Head.message_type)
  return message_type_;
}
inline void Head::set_message_type(::google::protobuf::uint32 value) {
  set_has_message_type();
  message_type_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.Head.message_type)
}

// -------------------------------------------------------------------

// CameraMessage

// required uint64 camera_id = 1;
inline bool CameraMessage::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraMessage::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraMessage::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraMessage::clear_camera_id() {
  camera_id_ = GOOGLE_ULONGLONG(0);
  clear_has_camera_id();
}
inline ::google::protobuf::uint64 CameraMessage::camera_id() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraMessage.camera_id)
  return camera_id_;
}
inline void CameraMessage::set_camera_id(::google::protobuf::uint64 value) {
  set_has_camera_id();
  camera_id_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.CameraMessage.camera_id)
}

// required string camera_ip = 2;
inline bool CameraMessage::has_camera_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraMessage::set_has_camera_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraMessage::clear_has_camera_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraMessage::clear_camera_ip() {
  if (camera_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ip_->clear();
  }
  clear_has_camera_ip();
}
inline const ::std::string& CameraMessage::camera_ip() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraMessage.camera_ip)
  return *camera_ip_;
}
inline void CameraMessage::set_camera_ip(const ::std::string& value) {
  set_has_camera_ip();
  if (camera_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ip_ = new ::std::string;
  }
  camera_ip_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.CameraMessage.camera_ip)
}
inline void CameraMessage::set_camera_ip(const char* value) {
  set_has_camera_ip();
  if (camera_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ip_ = new ::std::string;
  }
  camera_ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.CameraMessage.camera_ip)
}
inline void CameraMessage::set_camera_ip(const char* value, size_t size) {
  set_has_camera_ip();
  if (camera_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ip_ = new ::std::string;
  }
  camera_ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.CameraMessage.camera_ip)
}
inline ::std::string* CameraMessage::mutable_camera_ip() {
  set_has_camera_ip();
  if (camera_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.CameraMessage.camera_ip)
  return camera_ip_;
}
inline ::std::string* CameraMessage::release_camera_ip() {
  clear_has_camera_ip();
  if (camera_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = camera_ip_;
    camera_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CameraMessage::set_allocated_camera_ip(::std::string* camera_ip) {
  if (camera_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete camera_ip_;
  }
  if (camera_ip) {
    set_has_camera_ip();
    camera_ip_ = camera_ip;
  } else {
    clear_has_camera_ip();
    camera_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.CameraMessage.camera_ip)
}

// required uint32 camera_port = 3;
inline bool CameraMessage::has_camera_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraMessage::set_has_camera_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraMessage::clear_has_camera_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraMessage::clear_camera_port() {
  camera_port_ = 0u;
  clear_has_camera_port();
}
inline ::google::protobuf::uint32 CameraMessage::camera_port() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraMessage.camera_port)
  return camera_port_;
}
inline void CameraMessage::set_camera_port(::google::protobuf::uint32 value) {
  set_has_camera_port();
  camera_port_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.CameraMessage.camera_port)
}

// required string camera_username = 4;
inline bool CameraMessage::has_camera_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraMessage::set_has_camera_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraMessage::clear_has_camera_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraMessage::clear_camera_username() {
  if (camera_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_username_->clear();
  }
  clear_has_camera_username();
}
inline const ::std::string& CameraMessage::camera_username() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraMessage.camera_username)
  return *camera_username_;
}
inline void CameraMessage::set_camera_username(const ::std::string& value) {
  set_has_camera_username();
  if (camera_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_username_ = new ::std::string;
  }
  camera_username_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.CameraMessage.camera_username)
}
inline void CameraMessage::set_camera_username(const char* value) {
  set_has_camera_username();
  if (camera_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_username_ = new ::std::string;
  }
  camera_username_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.CameraMessage.camera_username)
}
inline void CameraMessage::set_camera_username(const char* value, size_t size) {
  set_has_camera_username();
  if (camera_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_username_ = new ::std::string;
  }
  camera_username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.CameraMessage.camera_username)
}
inline ::std::string* CameraMessage::mutable_camera_username() {
  set_has_camera_username();
  if (camera_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.CameraMessage.camera_username)
  return camera_username_;
}
inline ::std::string* CameraMessage::release_camera_username() {
  clear_has_camera_username();
  if (camera_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = camera_username_;
    camera_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CameraMessage::set_allocated_camera_username(::std::string* camera_username) {
  if (camera_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete camera_username_;
  }
  if (camera_username) {
    set_has_camera_username();
    camera_username_ = camera_username;
  } else {
    clear_has_camera_username();
    camera_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.CameraMessage.camera_username)
}

// required string camera_passowrd = 5;
inline bool CameraMessage::has_camera_passowrd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraMessage::set_has_camera_passowrd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraMessage::clear_has_camera_passowrd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraMessage::clear_camera_passowrd() {
  if (camera_passowrd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_passowrd_->clear();
  }
  clear_has_camera_passowrd();
}
inline const ::std::string& CameraMessage::camera_passowrd() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraMessage.camera_passowrd)
  return *camera_passowrd_;
}
inline void CameraMessage::set_camera_passowrd(const ::std::string& value) {
  set_has_camera_passowrd();
  if (camera_passowrd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_passowrd_ = new ::std::string;
  }
  camera_passowrd_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.CameraMessage.camera_passowrd)
}
inline void CameraMessage::set_camera_passowrd(const char* value) {
  set_has_camera_passowrd();
  if (camera_passowrd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_passowrd_ = new ::std::string;
  }
  camera_passowrd_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.CameraMessage.camera_passowrd)
}
inline void CameraMessage::set_camera_passowrd(const char* value, size_t size) {
  set_has_camera_passowrd();
  if (camera_passowrd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_passowrd_ = new ::std::string;
  }
  camera_passowrd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.CameraMessage.camera_passowrd)
}
inline ::std::string* CameraMessage::mutable_camera_passowrd() {
  set_has_camera_passowrd();
  if (camera_passowrd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_passowrd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.CameraMessage.camera_passowrd)
  return camera_passowrd_;
}
inline ::std::string* CameraMessage::release_camera_passowrd() {
  clear_has_camera_passowrd();
  if (camera_passowrd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = camera_passowrd_;
    camera_passowrd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CameraMessage::set_allocated_camera_passowrd(::std::string* camera_passowrd) {
  if (camera_passowrd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete camera_passowrd_;
  }
  if (camera_passowrd) {
    set_has_camera_passowrd();
    camera_passowrd_ = camera_passowrd;
  } else {
    clear_has_camera_passowrd();
    camera_passowrd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.CameraMessage.camera_passowrd)
}

// -------------------------------------------------------------------

// Login

// required uint64 id = 1;
inline bool Login::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Login::id() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.Login.id)
  return id_;
}
inline void Login::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.Login.id)
}

// required string username = 2;
inline bool Login::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.Login.username)
  return *username_;
}
inline void Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.Login.username)
}
inline void Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.Login.username)
}
inline void Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.Login.username)
}
inline ::std::string* Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.Login.username)
  return username_;
}
inline ::std::string* Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.Login.username)
}

// required string password = 3;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.Login.password)
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.Login.password)
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.Login.password)
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.Login.password)
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.Login.password)
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.Login.password)
}

// required uint32 version = 4;
inline bool Login::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Login::version() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.Login.version)
  return version_;
}
inline void Login::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.Login.version)
}

// required string os = 5;
inline bool Login::has_os() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Login::set_has_os() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Login::clear_has_os() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Login::clear_os() {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& Login::os() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.Login.os)
  return *os_;
}
inline void Login::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.Login.os)
}
inline void Login::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.Login.os)
}
inline void Login::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.Login.os)
}
inline ::std::string* Login::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.Login.os)
  return os_;
}
inline ::std::string* Login::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.Login.os)
}

// -------------------------------------------------------------------

// LoginResult

// required .PictureProtocol.LoginResult.Flag flag = 1;
inline bool LoginResult::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResult::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResult::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResult::clear_flag() {
  flag_ = 1;
  clear_has_flag();
}
inline ::PictureProtocol::LoginResult_Flag LoginResult::flag() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.LoginResult.flag)
  return static_cast< ::PictureProtocol::LoginResult_Flag >(flag_);
}
inline void LoginResult::set_flag(::PictureProtocol::LoginResult_Flag value) {
  assert(::PictureProtocol::LoginResult_Flag_IsValid(value));
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.LoginResult.flag)
}

// repeated .PictureProtocol.CameraMessage camera_message = 2;
inline int LoginResult::camera_message_size() const {
  return camera_message_.size();
}
inline void LoginResult::clear_camera_message() {
  camera_message_.Clear();
}
inline const ::PictureProtocol::CameraMessage& LoginResult::camera_message(int index) const {
  // @@protoc_insertion_point(field_get:PictureProtocol.LoginResult.camera_message)
  return camera_message_.Get(index);
}
inline ::PictureProtocol::CameraMessage* LoginResult::mutable_camera_message(int index) {
  // @@protoc_insertion_point(field_mutable:PictureProtocol.LoginResult.camera_message)
  return camera_message_.Mutable(index);
}
inline ::PictureProtocol::CameraMessage* LoginResult::add_camera_message() {
  // @@protoc_insertion_point(field_add:PictureProtocol.LoginResult.camera_message)
  return camera_message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >&
LoginResult::camera_message() const {
  // @@protoc_insertion_point(field_list:PictureProtocol.LoginResult.camera_message)
  return camera_message_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >*
LoginResult::mutable_camera_message() {
  // @@protoc_insertion_point(field_mutable_list:PictureProtocol.LoginResult.camera_message)
  return &camera_message_;
}

// optional string message = 3;
inline bool LoginResult::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResult::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResult::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResult::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& LoginResult::message() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.LoginResult.message)
  return *message_;
}
inline void LoginResult::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.LoginResult.message)
}
inline void LoginResult::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.LoginResult.message)
}
inline void LoginResult::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.LoginResult.message)
}
inline ::std::string* LoginResult::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.LoginResult.message)
  return message_;
}
inline ::std::string* LoginResult::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResult::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.LoginResult.message)
}

// -------------------------------------------------------------------

// ChangeCamera

// repeated .PictureProtocol.CameraMessage camera_message = 1;
inline int ChangeCamera::camera_message_size() const {
  return camera_message_.size();
}
inline void ChangeCamera::clear_camera_message() {
  camera_message_.Clear();
}
inline const ::PictureProtocol::CameraMessage& ChangeCamera::camera_message(int index) const {
  // @@protoc_insertion_point(field_get:PictureProtocol.ChangeCamera.camera_message)
  return camera_message_.Get(index);
}
inline ::PictureProtocol::CameraMessage* ChangeCamera::mutable_camera_message(int index) {
  // @@protoc_insertion_point(field_mutable:PictureProtocol.ChangeCamera.camera_message)
  return camera_message_.Mutable(index);
}
inline ::PictureProtocol::CameraMessage* ChangeCamera::add_camera_message() {
  // @@protoc_insertion_point(field_add:PictureProtocol.ChangeCamera.camera_message)
  return camera_message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >&
ChangeCamera::camera_message() const {
  // @@protoc_insertion_point(field_list:PictureProtocol.ChangeCamera.camera_message)
  return camera_message_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraMessage >*
ChangeCamera::mutable_camera_message() {
  // @@protoc_insertion_point(field_mutable_list:PictureProtocol.ChangeCamera.camera_message)
  return &camera_message_;
}

// -------------------------------------------------------------------

// SendFaceMessage

// required uint64 camera_id = 1;
inline bool SendFaceMessage::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendFaceMessage::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendFaceMessage::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendFaceMessage::clear_camera_id() {
  camera_id_ = GOOGLE_ULONGLONG(0);
  clear_has_camera_id();
}
inline ::google::protobuf::uint64 SendFaceMessage::camera_id() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.camera_id)
  return camera_id_;
}
inline void SendFaceMessage::set_camera_id(::google::protobuf::uint64 value) {
  set_has_camera_id();
  camera_id_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.camera_id)
}

// required uint32 face_score = 2;
inline bool SendFaceMessage::has_face_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendFaceMessage::set_has_face_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendFaceMessage::clear_has_face_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendFaceMessage::clear_face_score() {
  face_score_ = 0u;
  clear_has_face_score();
}
inline ::google::protobuf::uint32 SendFaceMessage::face_score() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.face_score)
  return face_score_;
}
inline void SendFaceMessage::set_face_score(::google::protobuf::uint32 value) {
  set_has_face_score();
  face_score_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.face_score)
}

// required bytes face_contrast_pic = 3;
inline bool SendFaceMessage::has_face_contrast_pic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendFaceMessage::set_has_face_contrast_pic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendFaceMessage::clear_has_face_contrast_pic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendFaceMessage::clear_face_contrast_pic() {
  if (face_contrast_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_contrast_pic_->clear();
  }
  clear_has_face_contrast_pic();
}
inline const ::std::string& SendFaceMessage::face_contrast_pic() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.face_contrast_pic)
  return *face_contrast_pic_;
}
inline void SendFaceMessage::set_face_contrast_pic(const ::std::string& value) {
  set_has_face_contrast_pic();
  if (face_contrast_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_contrast_pic_ = new ::std::string;
  }
  face_contrast_pic_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.face_contrast_pic)
}
inline void SendFaceMessage::set_face_contrast_pic(const char* value) {
  set_has_face_contrast_pic();
  if (face_contrast_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_contrast_pic_ = new ::std::string;
  }
  face_contrast_pic_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendFaceMessage.face_contrast_pic)
}
inline void SendFaceMessage::set_face_contrast_pic(const void* value, size_t size) {
  set_has_face_contrast_pic();
  if (face_contrast_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_contrast_pic_ = new ::std::string;
  }
  face_contrast_pic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendFaceMessage.face_contrast_pic)
}
inline ::std::string* SendFaceMessage::mutable_face_contrast_pic() {
  set_has_face_contrast_pic();
  if (face_contrast_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_contrast_pic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendFaceMessage.face_contrast_pic)
  return face_contrast_pic_;
}
inline ::std::string* SendFaceMessage::release_face_contrast_pic() {
  clear_has_face_contrast_pic();
  if (face_contrast_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = face_contrast_pic_;
    face_contrast_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendFaceMessage::set_allocated_face_contrast_pic(::std::string* face_contrast_pic) {
  if (face_contrast_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete face_contrast_pic_;
  }
  if (face_contrast_pic) {
    set_has_face_contrast_pic();
    face_contrast_pic_ = face_contrast_pic;
  } else {
    clear_has_face_contrast_pic();
    face_contrast_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendFaceMessage.face_contrast_pic)
}

// optional .PictureProtocol.RectPicture rect_pic_face = 4;
inline bool SendFaceMessage::has_rect_pic_face() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendFaceMessage::set_has_rect_pic_face() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendFaceMessage::clear_has_rect_pic_face() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendFaceMessage::clear_rect_pic_face() {
  if (rect_pic_face_ != NULL) rect_pic_face_->::PictureProtocol::RectPicture::Clear();
  clear_has_rect_pic_face();
}
inline const ::PictureProtocol::RectPicture& SendFaceMessage::rect_pic_face() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.rect_pic_face)
  return rect_pic_face_ != NULL ? *rect_pic_face_ : *default_instance_->rect_pic_face_;
}
inline ::PictureProtocol::RectPicture* SendFaceMessage::mutable_rect_pic_face() {
  set_has_rect_pic_face();
  if (rect_pic_face_ == NULL) rect_pic_face_ = new ::PictureProtocol::RectPicture;
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendFaceMessage.rect_pic_face)
  return rect_pic_face_;
}
inline ::PictureProtocol::RectPicture* SendFaceMessage::release_rect_pic_face() {
  clear_has_rect_pic_face();
  ::PictureProtocol::RectPicture* temp = rect_pic_face_;
  rect_pic_face_ = NULL;
  return temp;
}
inline void SendFaceMessage::set_allocated_rect_pic_face(::PictureProtocol::RectPicture* rect_pic_face) {
  delete rect_pic_face_;
  rect_pic_face_ = rect_pic_face;
  if (rect_pic_face) {
    set_has_rect_pic_face();
  } else {
    clear_has_rect_pic_face();
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendFaceMessage.rect_pic_face)
}

// optional bytes face_show_pic = 5;
inline bool SendFaceMessage::has_face_show_pic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendFaceMessage::set_has_face_show_pic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendFaceMessage::clear_has_face_show_pic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendFaceMessage::clear_face_show_pic() {
  if (face_show_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_show_pic_->clear();
  }
  clear_has_face_show_pic();
}
inline const ::std::string& SendFaceMessage::face_show_pic() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.face_show_pic)
  return *face_show_pic_;
}
inline void SendFaceMessage::set_face_show_pic(const ::std::string& value) {
  set_has_face_show_pic();
  if (face_show_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_show_pic_ = new ::std::string;
  }
  face_show_pic_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.face_show_pic)
}
inline void SendFaceMessage::set_face_show_pic(const char* value) {
  set_has_face_show_pic();
  if (face_show_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_show_pic_ = new ::std::string;
  }
  face_show_pic_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendFaceMessage.face_show_pic)
}
inline void SendFaceMessage::set_face_show_pic(const void* value, size_t size) {
  set_has_face_show_pic();
  if (face_show_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_show_pic_ = new ::std::string;
  }
  face_show_pic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendFaceMessage.face_show_pic)
}
inline ::std::string* SendFaceMessage::mutable_face_show_pic() {
  set_has_face_show_pic();
  if (face_show_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_show_pic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendFaceMessage.face_show_pic)
  return face_show_pic_;
}
inline ::std::string* SendFaceMessage::release_face_show_pic() {
  clear_has_face_show_pic();
  if (face_show_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = face_show_pic_;
    face_show_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendFaceMessage::set_allocated_face_show_pic(::std::string* face_show_pic) {
  if (face_show_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete face_show_pic_;
  }
  if (face_show_pic) {
    set_has_face_show_pic();
    face_show_pic_ = face_show_pic;
  } else {
    clear_has_face_show_pic();
    face_show_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendFaceMessage.face_show_pic)
}

// optional .PictureProtocol.RectPicture rect_pic_show = 6;
inline bool SendFaceMessage::has_rect_pic_show() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SendFaceMessage::set_has_rect_pic_show() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SendFaceMessage::clear_has_rect_pic_show() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SendFaceMessage::clear_rect_pic_show() {
  if (rect_pic_show_ != NULL) rect_pic_show_->::PictureProtocol::RectPicture::Clear();
  clear_has_rect_pic_show();
}
inline const ::PictureProtocol::RectPicture& SendFaceMessage::rect_pic_show() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.rect_pic_show)
  return rect_pic_show_ != NULL ? *rect_pic_show_ : *default_instance_->rect_pic_show_;
}
inline ::PictureProtocol::RectPicture* SendFaceMessage::mutable_rect_pic_show() {
  set_has_rect_pic_show();
  if (rect_pic_show_ == NULL) rect_pic_show_ = new ::PictureProtocol::RectPicture;
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendFaceMessage.rect_pic_show)
  return rect_pic_show_;
}
inline ::PictureProtocol::RectPicture* SendFaceMessage::release_rect_pic_show() {
  clear_has_rect_pic_show();
  ::PictureProtocol::RectPicture* temp = rect_pic_show_;
  rect_pic_show_ = NULL;
  return temp;
}
inline void SendFaceMessage::set_allocated_rect_pic_show(::PictureProtocol::RectPicture* rect_pic_show) {
  delete rect_pic_show_;
  rect_pic_show_ = rect_pic_show;
  if (rect_pic_show) {
    set_has_rect_pic_show();
  } else {
    clear_has_rect_pic_show();
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendFaceMessage.rect_pic_show)
}

// required uint64 camera_time = 7;
inline bool SendFaceMessage::has_camera_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendFaceMessage::set_has_camera_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendFaceMessage::clear_has_camera_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendFaceMessage::clear_camera_time() {
  camera_time_ = GOOGLE_ULONGLONG(0);
  clear_has_camera_time();
}
inline ::google::protobuf::uint64 SendFaceMessage::camera_time() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.camera_time)
  return camera_time_;
}
inline void SendFaceMessage::set_camera_time(::google::protobuf::uint64 value) {
  set_has_camera_time();
  camera_time_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.camera_time)
}

// required uint64 program_time = 8;
inline bool SendFaceMessage::has_program_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SendFaceMessage::set_has_program_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SendFaceMessage::clear_has_program_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SendFaceMessage::clear_program_time() {
  program_time_ = GOOGLE_ULONGLONG(0);
  clear_has_program_time();
}
inline ::google::protobuf::uint64 SendFaceMessage::program_time() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.program_time)
  return program_time_;
}
inline void SendFaceMessage::set_program_time(::google::protobuf::uint64 value) {
  set_has_program_time();
  program_time_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.program_time)
}

// required uint64 send_time = 9;
inline bool SendFaceMessage::has_send_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SendFaceMessage::set_has_send_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SendFaceMessage::clear_has_send_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SendFaceMessage::clear_send_time() {
  send_time_ = GOOGLE_ULONGLONG(0);
  clear_has_send_time();
}
inline ::google::protobuf::uint64 SendFaceMessage::send_time() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.send_time)
  return send_time_;
}
inline void SendFaceMessage::set_send_time(::google::protobuf::uint64 value) {
  set_has_send_time();
  send_time_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.send_time)
}

// required string picture_name = 10;
inline bool SendFaceMessage::has_picture_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SendFaceMessage::set_has_picture_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SendFaceMessage::clear_has_picture_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SendFaceMessage::clear_picture_name() {
  if (picture_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_->clear();
  }
  clear_has_picture_name();
}
inline const ::std::string& SendFaceMessage::picture_name() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.picture_name)
  return *picture_name_;
}
inline void SendFaceMessage::set_picture_name(const ::std::string& value) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.picture_name)
}
inline void SendFaceMessage::set_picture_name(const char* value) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendFaceMessage.picture_name)
}
inline void SendFaceMessage::set_picture_name(const char* value, size_t size) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendFaceMessage.picture_name)
}
inline ::std::string* SendFaceMessage::mutable_picture_name() {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendFaceMessage.picture_name)
  return picture_name_;
}
inline ::std::string* SendFaceMessage::release_picture_name() {
  clear_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = picture_name_;
    picture_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendFaceMessage::set_allocated_picture_name(::std::string* picture_name) {
  if (picture_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete picture_name_;
  }
  if (picture_name) {
    set_has_picture_name();
    picture_name_ = picture_name;
  } else {
    clear_has_picture_name();
    picture_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendFaceMessage.picture_name)
}

// optional bytes back_pic = 11;
inline bool SendFaceMessage::has_back_pic() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SendFaceMessage::set_has_back_pic() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SendFaceMessage::clear_has_back_pic() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SendFaceMessage::clear_back_pic() {
  if (back_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_->clear();
  }
  clear_has_back_pic();
}
inline const ::std::string& SendFaceMessage::back_pic() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.back_pic)
  return *back_pic_;
}
inline void SendFaceMessage::set_back_pic(const ::std::string& value) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendFaceMessage.back_pic)
}
inline void SendFaceMessage::set_back_pic(const char* value) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendFaceMessage.back_pic)
}
inline void SendFaceMessage::set_back_pic(const void* value, size_t size) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendFaceMessage.back_pic)
}
inline ::std::string* SendFaceMessage::mutable_back_pic() {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendFaceMessage.back_pic)
  return back_pic_;
}
inline ::std::string* SendFaceMessage::release_back_pic() {
  clear_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = back_pic_;
    back_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendFaceMessage::set_allocated_back_pic(::std::string* back_pic) {
  if (back_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete back_pic_;
  }
  if (back_pic) {
    set_has_back_pic();
    back_pic_ = back_pic;
  } else {
    clear_has_back_pic();
    back_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendFaceMessage.back_pic)
}

// optional .PictureProtocol.RectPicture rect_pic_back = 12;
inline bool SendFaceMessage::has_rect_pic_back() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SendFaceMessage::set_has_rect_pic_back() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SendFaceMessage::clear_has_rect_pic_back() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SendFaceMessage::clear_rect_pic_back() {
  if (rect_pic_back_ != NULL) rect_pic_back_->::PictureProtocol::RectPicture::Clear();
  clear_has_rect_pic_back();
}
inline const ::PictureProtocol::RectPicture& SendFaceMessage::rect_pic_back() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendFaceMessage.rect_pic_back)
  return rect_pic_back_ != NULL ? *rect_pic_back_ : *default_instance_->rect_pic_back_;
}
inline ::PictureProtocol::RectPicture* SendFaceMessage::mutable_rect_pic_back() {
  set_has_rect_pic_back();
  if (rect_pic_back_ == NULL) rect_pic_back_ = new ::PictureProtocol::RectPicture;
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendFaceMessage.rect_pic_back)
  return rect_pic_back_;
}
inline ::PictureProtocol::RectPicture* SendFaceMessage::release_rect_pic_back() {
  clear_has_rect_pic_back();
  ::PictureProtocol::RectPicture* temp = rect_pic_back_;
  rect_pic_back_ = NULL;
  return temp;
}
inline void SendFaceMessage::set_allocated_rect_pic_back(::PictureProtocol::RectPicture* rect_pic_back) {
  delete rect_pic_back_;
  rect_pic_back_ = rect_pic_back;
  if (rect_pic_back) {
    set_has_rect_pic_back();
  } else {
    clear_has_rect_pic_back();
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendFaceMessage.rect_pic_back)
}

// -------------------------------------------------------------------

// SendCarMessage

// required uint64 camera_id = 1;
inline bool SendCarMessage::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendCarMessage::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendCarMessage::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendCarMessage::clear_camera_id() {
  camera_id_ = GOOGLE_ULONGLONG(0);
  clear_has_camera_id();
}
inline ::google::protobuf::uint64 SendCarMessage::camera_id() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.camera_id)
  return camera_id_;
}
inline void SendCarMessage::set_camera_id(::google::protobuf::uint64 value) {
  set_has_camera_id();
  camera_id_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.camera_id)
}

// required uint32 license_score = 2;
inline bool SendCarMessage::has_license_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendCarMessage::set_has_license_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendCarMessage::clear_has_license_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendCarMessage::clear_license_score() {
  license_score_ = 0u;
  clear_has_license_score();
}
inline ::google::protobuf::uint32 SendCarMessage::license_score() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.license_score)
  return license_score_;
}
inline void SendCarMessage::set_license_score(::google::protobuf::uint32 value) {
  set_has_license_score();
  license_score_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.license_score)
}

// required string license_plate_num = 3;
inline bool SendCarMessage::has_license_plate_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendCarMessage::set_has_license_plate_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendCarMessage::clear_has_license_plate_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendCarMessage::clear_license_plate_num() {
  if (license_plate_num_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_num_->clear();
  }
  clear_has_license_plate_num();
}
inline const ::std::string& SendCarMessage::license_plate_num() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.license_plate_num)
  return *license_plate_num_;
}
inline void SendCarMessage::set_license_plate_num(const ::std::string& value) {
  set_has_license_plate_num();
  if (license_plate_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_num_ = new ::std::string;
  }
  license_plate_num_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.license_plate_num)
}
inline void SendCarMessage::set_license_plate_num(const char* value) {
  set_has_license_plate_num();
  if (license_plate_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_num_ = new ::std::string;
  }
  license_plate_num_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendCarMessage.license_plate_num)
}
inline void SendCarMessage::set_license_plate_num(const char* value, size_t size) {
  set_has_license_plate_num();
  if (license_plate_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_num_ = new ::std::string;
  }
  license_plate_num_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendCarMessage.license_plate_num)
}
inline ::std::string* SendCarMessage::mutable_license_plate_num() {
  set_has_license_plate_num();
  if (license_plate_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_num_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.license_plate_num)
  return license_plate_num_;
}
inline ::std::string* SendCarMessage::release_license_plate_num() {
  clear_has_license_plate_num();
  if (license_plate_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = license_plate_num_;
    license_plate_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCarMessage::set_allocated_license_plate_num(::std::string* license_plate_num) {
  if (license_plate_num_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete license_plate_num_;
  }
  if (license_plate_num) {
    set_has_license_plate_num();
    license_plate_num_ = license_plate_num;
  } else {
    clear_has_license_plate_num();
    license_plate_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.license_plate_num)
}

// optional string license_plate_color = 4;
inline bool SendCarMessage::has_license_plate_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendCarMessage::set_has_license_plate_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendCarMessage::clear_has_license_plate_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendCarMessage::clear_license_plate_color() {
  if (license_plate_color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_color_->clear();
  }
  clear_has_license_plate_color();
}
inline const ::std::string& SendCarMessage::license_plate_color() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.license_plate_color)
  return *license_plate_color_;
}
inline void SendCarMessage::set_license_plate_color(const ::std::string& value) {
  set_has_license_plate_color();
  if (license_plate_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_color_ = new ::std::string;
  }
  license_plate_color_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.license_plate_color)
}
inline void SendCarMessage::set_license_plate_color(const char* value) {
  set_has_license_plate_color();
  if (license_plate_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_color_ = new ::std::string;
  }
  license_plate_color_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendCarMessage.license_plate_color)
}
inline void SendCarMessage::set_license_plate_color(const char* value, size_t size) {
  set_has_license_plate_color();
  if (license_plate_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_color_ = new ::std::string;
  }
  license_plate_color_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendCarMessage.license_plate_color)
}
inline ::std::string* SendCarMessage::mutable_license_plate_color() {
  set_has_license_plate_color();
  if (license_plate_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_color_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.license_plate_color)
  return license_plate_color_;
}
inline ::std::string* SendCarMessage::release_license_plate_color() {
  clear_has_license_plate_color();
  if (license_plate_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = license_plate_color_;
    license_plate_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCarMessage::set_allocated_license_plate_color(::std::string* license_plate_color) {
  if (license_plate_color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete license_plate_color_;
  }
  if (license_plate_color) {
    set_has_license_plate_color();
    license_plate_color_ = license_plate_color;
  } else {
    clear_has_license_plate_color();
    license_plate_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.license_plate_color)
}

// optional string license_car_color = 5;
inline bool SendCarMessage::has_license_car_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendCarMessage::set_has_license_car_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendCarMessage::clear_has_license_car_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendCarMessage::clear_license_car_color() {
  if (license_car_color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_car_color_->clear();
  }
  clear_has_license_car_color();
}
inline const ::std::string& SendCarMessage::license_car_color() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.license_car_color)
  return *license_car_color_;
}
inline void SendCarMessage::set_license_car_color(const ::std::string& value) {
  set_has_license_car_color();
  if (license_car_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_car_color_ = new ::std::string;
  }
  license_car_color_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.license_car_color)
}
inline void SendCarMessage::set_license_car_color(const char* value) {
  set_has_license_car_color();
  if (license_car_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_car_color_ = new ::std::string;
  }
  license_car_color_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendCarMessage.license_car_color)
}
inline void SendCarMessage::set_license_car_color(const char* value, size_t size) {
  set_has_license_car_color();
  if (license_car_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_car_color_ = new ::std::string;
  }
  license_car_color_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendCarMessage.license_car_color)
}
inline ::std::string* SendCarMessage::mutable_license_car_color() {
  set_has_license_car_color();
  if (license_car_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_car_color_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.license_car_color)
  return license_car_color_;
}
inline ::std::string* SendCarMessage::release_license_car_color() {
  clear_has_license_car_color();
  if (license_car_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = license_car_color_;
    license_car_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCarMessage::set_allocated_license_car_color(::std::string* license_car_color) {
  if (license_car_color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete license_car_color_;
  }
  if (license_car_color) {
    set_has_license_car_color();
    license_car_color_ = license_car_color;
  } else {
    clear_has_license_car_color();
    license_car_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.license_car_color)
}

// optional string license_plate_type = 6;
inline bool SendCarMessage::has_license_plate_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SendCarMessage::set_has_license_plate_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SendCarMessage::clear_has_license_plate_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SendCarMessage::clear_license_plate_type() {
  if (license_plate_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_type_->clear();
  }
  clear_has_license_plate_type();
}
inline const ::std::string& SendCarMessage::license_plate_type() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.license_plate_type)
  return *license_plate_type_;
}
inline void SendCarMessage::set_license_plate_type(const ::std::string& value) {
  set_has_license_plate_type();
  if (license_plate_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_type_ = new ::std::string;
  }
  license_plate_type_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.license_plate_type)
}
inline void SendCarMessage::set_license_plate_type(const char* value) {
  set_has_license_plate_type();
  if (license_plate_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_type_ = new ::std::string;
  }
  license_plate_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendCarMessage.license_plate_type)
}
inline void SendCarMessage::set_license_plate_type(const char* value, size_t size) {
  set_has_license_plate_type();
  if (license_plate_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_type_ = new ::std::string;
  }
  license_plate_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendCarMessage.license_plate_type)
}
inline ::std::string* SendCarMessage::mutable_license_plate_type() {
  set_has_license_plate_type();
  if (license_plate_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.license_plate_type)
  return license_plate_type_;
}
inline ::std::string* SendCarMessage::release_license_plate_type() {
  clear_has_license_plate_type();
  if (license_plate_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = license_plate_type_;
    license_plate_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCarMessage::set_allocated_license_plate_type(::std::string* license_plate_type) {
  if (license_plate_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete license_plate_type_;
  }
  if (license_plate_type) {
    set_has_license_plate_type();
    license_plate_type_ = license_plate_type;
  } else {
    clear_has_license_plate_type();
    license_plate_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.license_plate_type)
}

// required bytes license_plate_pic = 7;
inline bool SendCarMessage::has_license_plate_pic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendCarMessage::set_has_license_plate_pic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendCarMessage::clear_has_license_plate_pic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendCarMessage::clear_license_plate_pic() {
  if (license_plate_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_pic_->clear();
  }
  clear_has_license_plate_pic();
}
inline const ::std::string& SendCarMessage::license_plate_pic() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.license_plate_pic)
  return *license_plate_pic_;
}
inline void SendCarMessage::set_license_plate_pic(const ::std::string& value) {
  set_has_license_plate_pic();
  if (license_plate_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_pic_ = new ::std::string;
  }
  license_plate_pic_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.license_plate_pic)
}
inline void SendCarMessage::set_license_plate_pic(const char* value) {
  set_has_license_plate_pic();
  if (license_plate_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_pic_ = new ::std::string;
  }
  license_plate_pic_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendCarMessage.license_plate_pic)
}
inline void SendCarMessage::set_license_plate_pic(const void* value, size_t size) {
  set_has_license_plate_pic();
  if (license_plate_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_pic_ = new ::std::string;
  }
  license_plate_pic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendCarMessage.license_plate_pic)
}
inline ::std::string* SendCarMessage::mutable_license_plate_pic() {
  set_has_license_plate_pic();
  if (license_plate_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_plate_pic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.license_plate_pic)
  return license_plate_pic_;
}
inline ::std::string* SendCarMessage::release_license_plate_pic() {
  clear_has_license_plate_pic();
  if (license_plate_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = license_plate_pic_;
    license_plate_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCarMessage::set_allocated_license_plate_pic(::std::string* license_plate_pic) {
  if (license_plate_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete license_plate_pic_;
  }
  if (license_plate_pic) {
    set_has_license_plate_pic();
    license_plate_pic_ = license_plate_pic;
  } else {
    clear_has_license_plate_pic();
    license_plate_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.license_plate_pic)
}

// optional .PictureProtocol.RectPicture rect_pic_license = 8;
inline bool SendCarMessage::has_rect_pic_license() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SendCarMessage::set_has_rect_pic_license() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SendCarMessage::clear_has_rect_pic_license() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SendCarMessage::clear_rect_pic_license() {
  if (rect_pic_license_ != NULL) rect_pic_license_->::PictureProtocol::RectPicture::Clear();
  clear_has_rect_pic_license();
}
inline const ::PictureProtocol::RectPicture& SendCarMessage::rect_pic_license() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.rect_pic_license)
  return rect_pic_license_ != NULL ? *rect_pic_license_ : *default_instance_->rect_pic_license_;
}
inline ::PictureProtocol::RectPicture* SendCarMessage::mutable_rect_pic_license() {
  set_has_rect_pic_license();
  if (rect_pic_license_ == NULL) rect_pic_license_ = new ::PictureProtocol::RectPicture;
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.rect_pic_license)
  return rect_pic_license_;
}
inline ::PictureProtocol::RectPicture* SendCarMessage::release_rect_pic_license() {
  clear_has_rect_pic_license();
  ::PictureProtocol::RectPicture* temp = rect_pic_license_;
  rect_pic_license_ = NULL;
  return temp;
}
inline void SendCarMessage::set_allocated_rect_pic_license(::PictureProtocol::RectPicture* rect_pic_license) {
  delete rect_pic_license_;
  rect_pic_license_ = rect_pic_license;
  if (rect_pic_license) {
    set_has_rect_pic_license();
  } else {
    clear_has_rect_pic_license();
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.rect_pic_license)
}

// required uint64 camera_time = 9;
inline bool SendCarMessage::has_camera_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SendCarMessage::set_has_camera_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SendCarMessage::clear_has_camera_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SendCarMessage::clear_camera_time() {
  camera_time_ = GOOGLE_ULONGLONG(0);
  clear_has_camera_time();
}
inline ::google::protobuf::uint64 SendCarMessage::camera_time() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.camera_time)
  return camera_time_;
}
inline void SendCarMessage::set_camera_time(::google::protobuf::uint64 value) {
  set_has_camera_time();
  camera_time_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.camera_time)
}

// required uint64 program_time = 10;
inline bool SendCarMessage::has_program_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SendCarMessage::set_has_program_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SendCarMessage::clear_has_program_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SendCarMessage::clear_program_time() {
  program_time_ = GOOGLE_ULONGLONG(0);
  clear_has_program_time();
}
inline ::google::protobuf::uint64 SendCarMessage::program_time() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.program_time)
  return program_time_;
}
inline void SendCarMessage::set_program_time(::google::protobuf::uint64 value) {
  set_has_program_time();
  program_time_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.program_time)
}

// required string picture_name = 11;
inline bool SendCarMessage::has_picture_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SendCarMessage::set_has_picture_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SendCarMessage::clear_has_picture_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SendCarMessage::clear_picture_name() {
  if (picture_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_->clear();
  }
  clear_has_picture_name();
}
inline const ::std::string& SendCarMessage::picture_name() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.picture_name)
  return *picture_name_;
}
inline void SendCarMessage::set_picture_name(const ::std::string& value) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.picture_name)
}
inline void SendCarMessage::set_picture_name(const char* value) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendCarMessage.picture_name)
}
inline void SendCarMessage::set_picture_name(const char* value, size_t size) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendCarMessage.picture_name)
}
inline ::std::string* SendCarMessage::mutable_picture_name() {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.picture_name)
  return picture_name_;
}
inline ::std::string* SendCarMessage::release_picture_name() {
  clear_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = picture_name_;
    picture_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCarMessage::set_allocated_picture_name(::std::string* picture_name) {
  if (picture_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete picture_name_;
  }
  if (picture_name) {
    set_has_picture_name();
    picture_name_ = picture_name;
  } else {
    clear_has_picture_name();
    picture_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.picture_name)
}

// optional bytes back_pic = 12;
inline bool SendCarMessage::has_back_pic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SendCarMessage::set_has_back_pic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SendCarMessage::clear_has_back_pic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SendCarMessage::clear_back_pic() {
  if (back_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_->clear();
  }
  clear_has_back_pic();
}
inline const ::std::string& SendCarMessage::back_pic() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.back_pic)
  return *back_pic_;
}
inline void SendCarMessage::set_back_pic(const ::std::string& value) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendCarMessage.back_pic)
}
inline void SendCarMessage::set_back_pic(const char* value) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendCarMessage.back_pic)
}
inline void SendCarMessage::set_back_pic(const void* value, size_t size) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendCarMessage.back_pic)
}
inline ::std::string* SendCarMessage::mutable_back_pic() {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.back_pic)
  return back_pic_;
}
inline ::std::string* SendCarMessage::release_back_pic() {
  clear_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = back_pic_;
    back_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCarMessage::set_allocated_back_pic(::std::string* back_pic) {
  if (back_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete back_pic_;
  }
  if (back_pic) {
    set_has_back_pic();
    back_pic_ = back_pic;
  } else {
    clear_has_back_pic();
    back_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.back_pic)
}

// optional .PictureProtocol.RectPicture rect_pic_back = 13;
inline bool SendCarMessage::has_rect_pic_back() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SendCarMessage::set_has_rect_pic_back() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SendCarMessage::clear_has_rect_pic_back() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SendCarMessage::clear_rect_pic_back() {
  if (rect_pic_back_ != NULL) rect_pic_back_->::PictureProtocol::RectPicture::Clear();
  clear_has_rect_pic_back();
}
inline const ::PictureProtocol::RectPicture& SendCarMessage::rect_pic_back() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendCarMessage.rect_pic_back)
  return rect_pic_back_ != NULL ? *rect_pic_back_ : *default_instance_->rect_pic_back_;
}
inline ::PictureProtocol::RectPicture* SendCarMessage::mutable_rect_pic_back() {
  set_has_rect_pic_back();
  if (rect_pic_back_ == NULL) rect_pic_back_ = new ::PictureProtocol::RectPicture;
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendCarMessage.rect_pic_back)
  return rect_pic_back_;
}
inline ::PictureProtocol::RectPicture* SendCarMessage::release_rect_pic_back() {
  clear_has_rect_pic_back();
  ::PictureProtocol::RectPicture* temp = rect_pic_back_;
  rect_pic_back_ = NULL;
  return temp;
}
inline void SendCarMessage::set_allocated_rect_pic_back(::PictureProtocol::RectPicture* rect_pic_back) {
  delete rect_pic_back_;
  rect_pic_back_ = rect_pic_back;
  if (rect_pic_back) {
    set_has_rect_pic_back();
  } else {
    clear_has_rect_pic_back();
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendCarMessage.rect_pic_back)
}

// -------------------------------------------------------------------

// SendBackMessage

// required uint64 camera_id = 1;
inline bool SendBackMessage::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendBackMessage::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendBackMessage::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendBackMessage::clear_camera_id() {
  camera_id_ = GOOGLE_ULONGLONG(0);
  clear_has_camera_id();
}
inline ::google::protobuf::uint64 SendBackMessage::camera_id() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendBackMessage.camera_id)
  return camera_id_;
}
inline void SendBackMessage::set_camera_id(::google::protobuf::uint64 value) {
  set_has_camera_id();
  camera_id_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.SendBackMessage.camera_id)
}

// required bytes back_pic = 2;
inline bool SendBackMessage::has_back_pic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendBackMessage::set_has_back_pic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendBackMessage::clear_has_back_pic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendBackMessage::clear_back_pic() {
  if (back_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_->clear();
  }
  clear_has_back_pic();
}
inline const ::std::string& SendBackMessage::back_pic() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendBackMessage.back_pic)
  return *back_pic_;
}
inline void SendBackMessage::set_back_pic(const ::std::string& value) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendBackMessage.back_pic)
}
inline void SendBackMessage::set_back_pic(const char* value) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendBackMessage.back_pic)
}
inline void SendBackMessage::set_back_pic(const void* value, size_t size) {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  back_pic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendBackMessage.back_pic)
}
inline ::std::string* SendBackMessage::mutable_back_pic() {
  set_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    back_pic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendBackMessage.back_pic)
  return back_pic_;
}
inline ::std::string* SendBackMessage::release_back_pic() {
  clear_has_back_pic();
  if (back_pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = back_pic_;
    back_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendBackMessage::set_allocated_back_pic(::std::string* back_pic) {
  if (back_pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete back_pic_;
  }
  if (back_pic) {
    set_has_back_pic();
    back_pic_ = back_pic;
  } else {
    clear_has_back_pic();
    back_pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendBackMessage.back_pic)
}

// required .PictureProtocol.RectPicture rect_pic_back = 3;
inline bool SendBackMessage::has_rect_pic_back() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendBackMessage::set_has_rect_pic_back() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendBackMessage::clear_has_rect_pic_back() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendBackMessage::clear_rect_pic_back() {
  if (rect_pic_back_ != NULL) rect_pic_back_->::PictureProtocol::RectPicture::Clear();
  clear_has_rect_pic_back();
}
inline const ::PictureProtocol::RectPicture& SendBackMessage::rect_pic_back() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendBackMessage.rect_pic_back)
  return rect_pic_back_ != NULL ? *rect_pic_back_ : *default_instance_->rect_pic_back_;
}
inline ::PictureProtocol::RectPicture* SendBackMessage::mutable_rect_pic_back() {
  set_has_rect_pic_back();
  if (rect_pic_back_ == NULL) rect_pic_back_ = new ::PictureProtocol::RectPicture;
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendBackMessage.rect_pic_back)
  return rect_pic_back_;
}
inline ::PictureProtocol::RectPicture* SendBackMessage::release_rect_pic_back() {
  clear_has_rect_pic_back();
  ::PictureProtocol::RectPicture* temp = rect_pic_back_;
  rect_pic_back_ = NULL;
  return temp;
}
inline void SendBackMessage::set_allocated_rect_pic_back(::PictureProtocol::RectPicture* rect_pic_back) {
  delete rect_pic_back_;
  rect_pic_back_ = rect_pic_back;
  if (rect_pic_back) {
    set_has_rect_pic_back();
  } else {
    clear_has_rect_pic_back();
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendBackMessage.rect_pic_back)
}

// required string picture_name = 4;
inline bool SendBackMessage::has_picture_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendBackMessage::set_has_picture_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendBackMessage::clear_has_picture_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendBackMessage::clear_picture_name() {
  if (picture_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_->clear();
  }
  clear_has_picture_name();
}
inline const ::std::string& SendBackMessage::picture_name() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.SendBackMessage.picture_name)
  return *picture_name_;
}
inline void SendBackMessage::set_picture_name(const ::std::string& value) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(value);
  // @@protoc_insertion_point(field_set:PictureProtocol.SendBackMessage.picture_name)
}
inline void SendBackMessage::set_picture_name(const char* value) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:PictureProtocol.SendBackMessage.picture_name)
}
inline void SendBackMessage::set_picture_name(const char* value, size_t size) {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  picture_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PictureProtocol.SendBackMessage.picture_name)
}
inline ::std::string* SendBackMessage::mutable_picture_name() {
  set_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picture_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PictureProtocol.SendBackMessage.picture_name)
  return picture_name_;
}
inline ::std::string* SendBackMessage::release_picture_name() {
  clear_has_picture_name();
  if (picture_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = picture_name_;
    picture_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendBackMessage::set_allocated_picture_name(::std::string* picture_name) {
  if (picture_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete picture_name_;
  }
  if (picture_name) {
    set_has_picture_name();
    picture_name_ = picture_name;
  } else {
    clear_has_picture_name();
    picture_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PictureProtocol.SendBackMessage.picture_name)
}

// -------------------------------------------------------------------

// RectPicture

// required uint32 x = 1;
inline bool RectPicture::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RectPicture::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RectPicture::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RectPicture::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 RectPicture::x() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.RectPicture.x)
  return x_;
}
inline void RectPicture::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.RectPicture.x)
}

// required uint32 y = 2;
inline bool RectPicture::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RectPicture::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RectPicture::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RectPicture::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 RectPicture::y() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.RectPicture.y)
  return y_;
}
inline void RectPicture::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.RectPicture.y)
}

// required uint32 width = 3;
inline bool RectPicture::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RectPicture::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RectPicture::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RectPicture::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 RectPicture::width() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.RectPicture.width)
  return width_;
}
inline void RectPicture::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.RectPicture.width)
}

// required uint32 height = 4;
inline bool RectPicture::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RectPicture::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RectPicture::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RectPicture::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 RectPicture::height() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.RectPicture.height)
  return height_;
}
inline void RectPicture::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.RectPicture.height)
}

// -------------------------------------------------------------------

// CameraStatus

// required uint64 camera_id = 1;
inline bool CameraStatus::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraStatus::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraStatus::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraStatus::clear_camera_id() {
  camera_id_ = GOOGLE_ULONGLONG(0);
  clear_has_camera_id();
}
inline ::google::protobuf::uint64 CameraStatus::camera_id() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraStatus.camera_id)
  return camera_id_;
}
inline void CameraStatus::set_camera_id(::google::protobuf::uint64 value) {
  set_has_camera_id();
  camera_id_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.CameraStatus.camera_id)
}

// required bool status = 2;
inline bool CameraStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraStatus::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool CameraStatus::status() const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraStatus.status)
  return status_;
}
inline void CameraStatus::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:PictureProtocol.CameraStatus.status)
}

// -------------------------------------------------------------------

// CameraStatusList

// repeated .PictureProtocol.CameraStatus cameraStatus = 1;
inline int CameraStatusList::camerastatus_size() const {
  return camerastatus_.size();
}
inline void CameraStatusList::clear_camerastatus() {
  camerastatus_.Clear();
}
inline const ::PictureProtocol::CameraStatus& CameraStatusList::camerastatus(int index) const {
  // @@protoc_insertion_point(field_get:PictureProtocol.CameraStatusList.cameraStatus)
  return camerastatus_.Get(index);
}
inline ::PictureProtocol::CameraStatus* CameraStatusList::mutable_camerastatus(int index) {
  // @@protoc_insertion_point(field_mutable:PictureProtocol.CameraStatusList.cameraStatus)
  return camerastatus_.Mutable(index);
}
inline ::PictureProtocol::CameraStatus* CameraStatusList::add_camerastatus() {
  // @@protoc_insertion_point(field_add:PictureProtocol.CameraStatusList.cameraStatus)
  return camerastatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraStatus >&
CameraStatusList::camerastatus() const {
  // @@protoc_insertion_point(field_list:PictureProtocol.CameraStatusList.cameraStatus)
  return camerastatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureProtocol::CameraStatus >*
CameraStatusList::mutable_camerastatus() {
  // @@protoc_insertion_point(field_mutable_list:PictureProtocol.CameraStatusList.cameraStatus)
  return &camerastatus_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PictureProtocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PictureProtocol::LoginResult_Flag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PictureProtocol::LoginResult_Flag>() {
  return ::PictureProtocol::LoginResult_Flag_descriptor();
}
template <> struct is_proto_enum< ::PictureProtocol::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PictureProtocol::MessageType>() {
  return ::PictureProtocol::MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SendPictureProtocol_2eproto__INCLUDED
